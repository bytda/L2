// Что выведет программа? Объяснить вывод программы.

package main

import (
    "fmt"
)

func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4]
    fmt.Println(b)
}
//Ответ:
/*
Программа выведет: 77, 78, 79
a[1:4] - означает, что из среза мы берем промежуток от  индекса 1 включительно
до индекса 4 не включительно( не забываем что отсчет идет с нуля)

если нам нужно выбрать остальную часть среза, можем использовать
конструкцию a[1:], то есть от 1 до конца среза
*/

/////////////////////////////////////////////////////////////////////////////////

// Что выведет программа? Объяснить вывод программы.
// Объяснить как работают defer’ы и их порядок вызовов.

package main

import (
	"fmt"
)


func test() (x int) {
	defer func() {
		x++
	}()
	x = 1
	return
}


func anotherTest() int {
	var x int
	defer func() {
		x++
	}()
	x = 1
	return x
}


func main() {
	fmt.Println(test())
	fmt.Println(anotherTest())
}

//Ответ:

/*
Программа выведет: 
2
1

defer выполняется после return, при этом последний defer выполняется первым, то есть снизу вверх (LIFO)


В первом случае выводится двойка, так как мы указали в выводе конкретное имя переменной и 
как мы знаем  defer срабатывает при завершении функции, но так как defer работает все с той
же именнованной переменной, то влияет на конечный резульат, когда во втором случае выводится 1
потому что переменная выходная не именованная и defer работает с локальной своей переменной
*/

/////////////////////////////////////////////////////////////////////////////////

//Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство 
// интерфейсов и их отличие от пустых интерфейсов.

package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}

//Ответ:

/*
Программа выведет:
nil
false

Это объясняется тем, что интерфейс состоит из типа данных и указателя на данных, указатель
в примере nil, но тип интерфейса *os.PathErrorа, а не nil поэтому интерфейс не равено nil 
во втором выводе в консоль

Интерфейс - это структура(iface), которая содержит метаданные - itable,
позволяющие определить тип, а также указатель на данные

Пустые интерфейсы - интерфейсы, не имеющие никаких методов, поэтому их реализуют все типы данных.
Пустым интерфейсам не нужен itab, поэтому для описания пустого интерфейса
используется структура eface проще, чем iface
*/

/////////////////////////////////////////////////////////////////////////////////

//Что выведет программа? Объяснить вывод программы.

package main

func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()

	for n := range ch {
		println(n)
	}
}

//Ответ:

/*
Программы выведет: Ошибку deadLock

Происходит это из-за ожидания в main'е закрытия канала ch, ситуацию можно решить
закрытием канала после цикла или же вместо закрытия канала поменять ниже цикл range на
такой же цикл for до 10, так как цикл range читает канал пока он открыт,
в нашем случае - бесконечно
*/

/////////////////////////////////////////////////////////////////////////////////

//Что выведет программа? Объяснить вывод программы.

package main

type customError struct {
	msg string
}

func (e *customError) Error() string {
	return e.msg
}

func test() *customError {
	{
		// do something
	}
	return nil
}

func main() {
	var err error
	err = test()
	if err != nil {
		println("error")
		return
	}
	println("ok")
}

//Ответ:

/*
Программы выведет:
error

В конструкции if выполняется если интерфейс не пустой, в нашем случае он не пустой, 
чтобы он был пустым надо что и тип и указатель были nil, а после функции у нас 
стал nil указатель, а тип - *customError
*/

/////////////////////////////////////////////////////////////////////////////////


// Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство
// слайсов и что происходит при передачи их в качестве аргументов функции.

package main

import (
	"fmt"
)

func main() {
	var s = []string{"1", "2", "3"}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(i []string) {
	i[0] = "3"
	i = append(i, "4")
	i[1] = "5"
	i = append(i, "6")
}

//Ответ:

/*
Программы выведет:

3, 2, 3 

Здесь в функцию передается срез по значению, то есть modifySlice работает с копией и append не 
влияют но первоначальный срез, но первый элемент поменлся так как к нему как раз мы обратились по 
указателю

Слайс представляет собой структуру, которую можно назвать оберткой для массива, эта структура
содержит указатель на первый элемент некоторого массива, который содержит элементы слайса, 
длину и вместимость (length и capacity) этого слайса, размер отображает текущую 
длину (количество элементов), а вместимость - длину внутреннего массива. Когда появляется 
необходимость расширить слайс (когда capacity начинает не хватать), память выделяется 
на бОльшую вместимость и происходит копирование предыдущего массива (то есть, указатель будет 
ссылаться уже на другой участок памяти). Append при недостаточном capacity удваивает его.

*/

//Что выведет программа? Объяснить вывод программы.

package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	c := make(chan int)

	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}

		close(c)
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()
	return c
}

func main() {

	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4 ,6, 8)
	c := merge(a, b )
	for v := range c {
		fmt.Println(v)
	}
}

//Ответ:

/*
Программы выведет:
Числа от 1 до 8 в разном порядке (из-за рандомного слипа) и потом бесконечные нули

Это происходит из-за ошибки использования конструкции select с каналами в функции merge,
которая создает общий канал "с" - результат слияния каналов a,b. В функции asChan
после того, как числа закончатся, каналы закрываются, но в merge нельзя определить,
закрыт канал или нет - цикл бесконечный, в select не предусмотрена ситуация, когда
канал закрыт и прочесть из него число не удается, поэтому при этой ситуации
выводится 0 - стандартное значение при инициализации числовой переменной. Также ошибка
есть и в использовании range уже в main - канал с из merge так и не закрылся, а main
в цикле range ожидает как раз момента закрытия канала. Для исправления ситуации необходимо
в merge закрыть канал с, а также предусмотреть закрытия каналов в select,
например: v, ok:= <- a, где ok покажет, удалось ли прочесть информацию или канал уже закрыт 
*/
