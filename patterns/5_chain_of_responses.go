/*
	Паттерн «Цепочка вызовов»

	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

/*
	Паттерн "цепочка вызовов" представляет собой цепочку обработчиков, которая принимает на вход
некий запрос и передает его обработчика к обработчику, каждый из них решает, сможет ли он обработать этот
запрос или нужно передать его по цепочке далее. Паттерн применяется в том случае, когда система должна обрабатывать разнообразные запросы, суть которых и методы
обработки заранее неизвестны, когда обработчики могут меняться динамически (например, при мастштабировании системы),
или когда их порядок должен быть строго последовательным (например, обработчики можно расположить по степени
сложности запроса - от самого простого случая, к самому трудному - первый обработчик обрабатывает самые рядовые
базовые вещи, последний в цепочке - редкие трудные случаи). Например, допустим, наше приложение подключается
к удаленному серверу, либо он вернет нам ожидаемый результат (валидный json или что-то такое), либо же
код ошибки - эти данные мы передаем цепочке, самый первый обработчик принимает валидные данные, если
они не валидны, он передает их дальше по обработчикам, которые занимаются обработкой конкретных ошибок.

Плюсы:

	Применение паттерна позволяет уменьшить зависимость между клиентом и обработчиком запроса,
количество и структуру обработчиков можно легко поменять, сами обработчики как элементы общей цепочки станут
более единообразными, похожими друг на друга, что улучшит читабельность кода

Минусы:

	Обработчики могут столкнуться с таким запросом, который не сможет обработать ни один элемент цепи,
поэтому есть риск того, что запрос может пройти через всю цепочку безрезультатно


Таким образом, паттерн "Цепочка вызовов" обычно применяют для следующих задач:
	1) Обработка заранее неизвестных разнообразных запросов различными методами
	2) Необходимо строго последовательное выполнение обработчиков
	3) Требуется возможность динамически изменять цепочку обработчиков
*/

type Request struct {
	data interface{}
}

type ChainHandler interface { //содержит методы обработчиков

	canHandle(request *Request) bool
	SetNext(handler ChainHandler)
	Handle(request *Request)
}

type HandlerA struct {
	next ChainHandler
}

func (s *HandlerA) canHandle(request *Request) bool { //проверяет запрос на возможность обработки

	/*...*/
}

func (s *HandlerA) SetNext(handler ChainHandler) { //задает следующий в цепи обработчик

	s.next = handler
}

// Handle проверяет возможность обработки запроса и обрабатывает его.
// Если Handle не может обработать запрос, то передает запрос следующему обработчику.
func (s *HandlerA) Handle(request *Request) {
	if s.canHandle(request) {
		/*...*/
		return
	}
	if s.next != nil {
		s.next.Handle(request)
	}
}

type HandlerB struct {
	next ChainHandler
}

func (s *HandlerB) canHandle(request *Request) bool { //проверяет запрос на возможность обработки

	/*...*/
}

func (s *HandlerB) SetNext(handler ChainHandler) { //задает следующий в цепи обработчик

	s.next = handler
}

// Handle проверяет возможность обработки запроса и обрабатывает его.
// Если Handle не может обработать запрос, то передает запрос следующему обработчику.
func (s *HandlerB) Handle(request *Request) {
	if s.canHandle(request) {
		/*...*/
		return
	}
	if s.next != nil {
		s.next.Handle(request)
	}
}
