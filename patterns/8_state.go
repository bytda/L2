/*
	Реализовать паттерн «Состояние»

	https://en.wikipedia.org/wiki/State_pattern
*/

/*
	Паттерн "состояние" используется когда в программе есть объекты, которые
могут часто менять свое состояние, и от текущего состояния зависит поведение этого объекта,
паттерн позволяет также избавиться от множества условных конструкций, которые
проверяют состояние объекта, для того, чтобы выполнить какое-либо действие. Например, некоторое
устройство с множеством датчиков, способное посылать какие-то команды или производить вычисления
на основе этих показаний (показания отражают текущее состояние устройства): так, если датчик
замера напряжения на аккумуляторе показывает, что все плохо, высвечивается предупреждающее значение,
если срабатывают датчики тормозной системы, подается команда изменить тормозное усилие, чтобы
стабилизировать движение, если скорость слишком высокая, включается ограничитель и так далее.
У объекта есть достаточно много состояний и они постоянно меняются, от их совокупности зависит,
какие действия осуществляет блок управления. Поэтому я предполагаю, что в сфере программирования
микроконтроллерных устройств такой паттерн должен встречаться довольно часто

Плюсы:

	Паттерн избавляет нас от множества конструкций if, которые были нужны, чтобы определить,
в каком состоянии объект, и что при нем нужно делать; концентрирует код, связанный
с действиями, зависящими от состояния, в одном месте

Минусы:

	Eсли состояний мало и они чаще всего статичны во время работы объекта, то
такой паттерн только усложнит код, не проявив себя эффективно

Таким образом, паттерн "Состояние" обычно применяют для следующих задач:

	1) Нужно использовать разные виды одного алгоритма
	2) Приведение похожих структур в единую структуру
	3) Необходимо скрыть детали реализации алгоритмов
	4) Когда есть большое дерево условных операторов, где каждая ветвь представляет собой вариацию алгоритма
*/

type Strategy interface { // Strategy содержит общую для всех стратегий функцию выполнения

	Execute(data Data)
}

type StrategyA struct {
}

func (s StrategyA) Execute(data Data) { // Execute выполняет алгоритм соответствующий стратегии А

	/*...*/
}

type Context struct { // Context позволяет сохранять и использовать определенную стратегию

	strategy Strategy
}

func (c *Context) SetStrategy(s Strategy) {
	c.strategy = s
}

func (c *Context) ExecStrategy(data Data) {
	c.strategy.Execute(data)
}

func StrategyClient() {
	context := new(Context)
	str := new(StrategyA)
	context.SetStrategy(str)
	context.ExecStrategy(Data{})
}
